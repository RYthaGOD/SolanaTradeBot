initial_balance: 10000.0,
            current_balance: 10000.0,
            trade_history: Vec::new(),
        }
    }
    
    pub fn process_market_data(&mut self, data: MarketData) -> Option<TradingSignal> {
        // Update market state
        let symbol_data = self.market_state
            .entry(data.symbol.clone())
            .or_insert_with(|| VecDeque::with_capacity(100));
        
        symbol_data.push_back(data.clone());
        if symbol_data.len() > 100 {
            symbol_data.pop_front();
        }
        
        // Simple moving average strategy for demo
        if symbol_data.len() >= 20 {
            let prices: Vec<f64> = symbol_data.iter().map(|d| d.price).collect();
            let sma_10: f64 = prices[prices.len()-10..].iter().sum::<f64>() / 10.0;
            let sma_20: f64 = prices.iter().sum::<f64>() / prices.len() as f64;
            
            if sma_10 > sma_20 * 1.02 && self.current_balance > data.price {
                let signal = TradingSignal {
                    id: uuid::Uuid::new_v4().to_string(),
                    action: TradeAction::Buy,
                    symbol: data.symbol.clone(),
                    price: data.price,
                    confidence: 0.7,
                    size: self.calculate_position_size(0.7, data.price),
                    stop_loss: data.price * 0.95,
                    take_profit: data.price * 1.05,
                    timestamp: Utc::now().timestamp(),
                };
                self.trade_history.push(signal.clone());
                return Some(signal);
            } else if sma_10 < sma_20 * 0.98 {
                if let Some(&position) = self.portfolio.get(&data.symbol) {
                    if position > 0.0 {
                        let signal = TradingSignal {
                            id: uuid::Uuid::new_v4().to_string(),
                            action: TradeAction::Sell,
                            symbol: data.symbol.clone(),
                            price: data.price,
                            confidence: 0.6,
                            size: position.min(self.calculate_position_size(0.6, data.price)),
                            stop_loss: data.price * 1.05,
                            take_profit: data.price * 0.95,
                            timestamp: Utc::now().timestamp(),
                        };
                        self.trade_history.push(signal.clone());
                        return Some(signal);
                    }
                }
            }
        }
        
        None
    }
    
    fn calculate_position_size(&self, confidence: f64, price: f64) -> f64 {
        let max_position_value = self.current_balance * 0.1; // Max 10% per trade
        let shares = (max_position_value * confidence) / price;
        shares.max(0.0)
    }
    
    pub fn execute_trade(&mut self, signal: &TradingSignal) -> bool {
        match signal.action {
            TradeAction::Buy => {
                let cost = signal.size * signal.price;
                if cost <= self.current_balance {
                    self.current_balance -= cost;
                    *self.portfolio.entry(signal.symbol.clone()).or_insert(0.0) += signal.size;
                    log::info!("✅ Bought {} {} at ${}", signal.size, signal.symbol, signal.price);
                    true
                } else {
                    log::warn!("❌ Insufficient balance for buy order");
                    false
                }
            }
            TradeAction::Sell => {
                if let Some(position) = self.portfolio.get_mut(&signal.symbol) {
                    if *position >= signal.size {
                        *position -= signal.size;
                        self.current_balance += signal.size * signal.price;