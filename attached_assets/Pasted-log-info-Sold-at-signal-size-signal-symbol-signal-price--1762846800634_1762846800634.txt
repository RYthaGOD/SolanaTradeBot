log::info!("âœ… Sold {} {} at ${}", signal.size, signal.symbol, signal.price);
                        true
                    } else {
                        log::warn!("âŒ Insufficient position for sell order");
                        false
                    }
                } else {
                    log::warn!("âŒ No position found for {}", signal.symbol);
                    false
                }
            }
            TradeAction::Hold => {
                false
            }
        }
    }
    
    pub fn get_portfolio_value(&self, current_prices: &HashMap<String, f64>) -> f64 {
        let positions_value: f64 = self.portfolio.iter()
            .map(|(symbol, size)| {
                current_prices.get(symbol).unwrap_or(&0.0) * size
            })
            .sum();
        
        self.current_balance + positions_value
    }
    
    pub fn get_portfolio_data(&self) -> HashMap<String, f64> {
        let mut data = self.portfolio.clone();
        data.insert("CASH".to_string(), self.current_balance);
        data
    }
}

pub async fn generate_trading_signals(
    engine: Arc<Mutex<TradingEngine>>,
    risk_manager: Arc<Mutex<super::risk_management::RiskManager>>,
) {
    log::info!("ðŸ¤– Starting trading signal generation");
    
    let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(10));
    
    loop {
        interval.tick().await;
        
        // In a real implementation, this would process actual market data
        // and generate signals based on ML models
        log::debug!("ðŸ” Generating trading signals...");
    }
}

### **backend/src/solana_integration.rs**
rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use rand::Rng;

#[derive(Debug, Clone)]
pub struct SolanaClient {
    pub connected: bool,
    pub wallet_balance: f64,
    pub transaction_count: u64,
}

impl SolanaClient {
    pub fn new() -> Self {
        Self {
            connected: true,
            wallet_balance: 10000.0,
            transaction_count: 0,
        }
    }
    
    pub async fn execute_trade(&mut self, symbol: &str, size: f64, is_buy: bool, price: f64) -> Result<String, String> {
        self.transaction_count += 1;
        
        // Simulate trade execution delay
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        
        // Simulate occasional failures
        if rand::thread_rng().gen_bool(0.05) { // 5% failure rate
            return Err("Simulated trade execution failure".to_string());
        }
        
        let action = if is_buy { "BUY" } else { "SELL" };
        let trade_id = format!("{}_{}_{}", action, symbol, self.transaction_count);
        
        log::info!("ðŸ”§ Executed trade: {} {} {} at ${}", action, size, symbol, price);
        
        Ok(trade_id)
    }
    
    pub fn get_balance(&self) -> f64 {
        self.wallet_balance
    }
}

pub async fn simulate_market_data(engine: Arc<Mutex<super::trading_engine::TradingEngine>>) {
    log::info!("ðŸ“Š Starting market data simulation");
    
    let symbols = vec!["SOL/USDC", "BTC/USDC", "ETH/USDC"];
    let mut prices = HashMap::new();
    prices.insert("SOL/USDC".to_string(), 100.0);
    prices.insert("BTC/USDC".to_string(), 50000.0);
    prices.insert("ETH/USDC".to_string(), 3000.0);
    
    let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(2));
    
    while let Some(_) = interval.tick().await {
        let mut rng = rand::thread_rng();
        
        for symbol in &symbols {
            let base_price = prices.get(*symbol).unwrap();
            let price_change = (rng.gen::<f64>() - 0.5) * base_price * 0.02; // Â±1% change
            let new_price = (base_price + price_change).max(base_price * 0.5).min(base_price * 1.5);